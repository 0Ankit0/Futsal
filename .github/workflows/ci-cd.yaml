name: Aspire CI/CD to DigitalOcean (Docker Compose)

on:
  push:
    branches: ["master"]

env:
  # Path to your Aspire AppHost project relative to the repository root
  APPHOST_PROJECT_PATH: "FutsalApi/FutsalApi.AppHost"
  # Name of your solution file (if different from directory structure)
  SOLUTION_FILE_NAME: "FutsalApi.sln" # Ensure this matches your actual solution file name

  # DigitalOcean Droplet secrets (DO_HOST, DO_USERNAME, DO_PASSWORD) are assumed to be set in your repo secrets
  REMOTE_APP_DIR: "/home/${{ secrets.DO_USERNAME }}/aspire-app" # Directory on droplet to deploy to

jobs:
  build-and-deploy:
    runs-on: self-hosted # Assuming your self-hosted runner has dotnet, docker, and docker-compose installed

    steps:
      - name: Check out code
        uses: actions/checkout@v3

      - name: Setup .NET SDK
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: "8.0.x" # Or whatever .NET version your Aspire app uses

      - name: Restore .NET tools and dependencies (including Aspire tooling)
        run: dotnet restore ${{ env.SOLUTION_FILE_NAME }}

      # This step builds the Docker images for all projects referenced by the AppHost
      # and generates the manifest and docker-compose.yml.
      # Requires Aspire 8.0.1+ for direct docker-compose generation
      - name: Build Aspire App and Generate Docker Compose
        run: |
          # Build the solution (this will also build Docker images for container projects)
          dotnet build ${{ env.SOLUTION_FILE_NAME }}

          # Publish the AppHost to generate the manifest AND docker-compose.yml
          # Using --output-path . will put manifest.json and docker-compose.yml at the root of the repo
          # or a sub-directory if you prefer. Let's put it in a 'deployment' folder.
          mkdir -p ./deployment
          dotnet publish ${{ env.APPHOST_PROJECT_PATH }} -c Release -o ./deployment /p:PublishProfile=DefaultContainer
          # Aspire automatically generates a docker-compose.yml when publishing with Container support
          # If not automatically generated, you might need to use `azd pipeline config` or similar,
          # but the `dotnet publish ... /p:PublishProfile=DefaultContainer` should handle it.

          # Verify generated files
          echo "Contents of ./deployment directory:"
          ls -la ./deployment
          if [ ! -f "./deployment/manifest.json" ]; then
            echo "ERROR: manifest.json was not generated!"
            exit 1
          fi
          if [ ! -f "./deployment/docker-compose.yml" ]; then
            echo "ERROR: docker-compose.yml was not generated! Ensure Aspire tooling is correct."
            exit 1
          fi

      - name: Deploy to DigitalOcean - Prepare remote
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.DO_HOST }}
          username: ${{ secrets.DO_USERNAME }}
          password: ${{ secrets.DO_PASSWORD }}
          script: |
            echo "Stopping and removing existing containers..."
            docker-compose -f ${{ env.REMOTE_APP_DIR }}/docker-compose.yml down || true
            docker rm $(docker ps -aq) || true # Remove any other dangling containers

            echo "Cleaning remote application directory..."
            rm -rf ${{ env.REMOTE_APP_DIR }}
            mkdir -p ${{ env.REMOTE_APP_DIR }}

      - name: Copy published files to DigitalOcean
        uses: appleboy/scp-action@master
        with:
          host: ${{ secrets.DO_HOST }}
          username: ${{ secrets.DO_USERNAME }}
          password: ${{ secrets.DO_PASSWORD }}
          source: "deployment/*" # Copy all generated files (manifest, docker-compose, etc.)
          target: "${{ env.REMOTE_APP_DIR }}"

      - name: Deploy Aspire Application with Docker Compose
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.DO_HOST }}
          username: ${{ secrets.DO_USERNAME }}
          password: ${{ secrets.DO_PASSWORD }}
          script: |
            echo "Navigating to remote app directory: ${{ env.REMOTE_APP_DIR }}"
            cd ${{ env.REMOTE_APP_DIR }}

            if [ -f "docker-compose.yml" ]; then
              echo "Starting Docker Compose services..."
              # Use --build to ensure images are built on the remote (if not already existing/pulled)
              # Use -d for detached mode
              # --wait will wait for services to be healthy
              docker-compose -f docker-compose.yml up -d --build --force-recreate --wait

              echo "Deployment complete with Docker Compose!"
            else
              echo "ERROR: docker-compose.yml not found in ${{ env.REMOTE_APP_DIR }}!"
              exit 1
            fi
